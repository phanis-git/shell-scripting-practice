Automation goals : speed and accuracy


variables:-

type1
--------
project_name="roboshop"
echo "Project name is :: ${project_name}"

type1 : special variables
-----------------
person1=$1
person2=$2

sh file2.sh phani kiran

type3
------
echo "Enter Email Id"
read email
echo "Your mail is $email"


type4
------
echo "Enter Password"
read -s password
echo "Your password is $password"

type5  Environment variables 
-----
These are accessing only within the session or process , if we kill process it wont work
export name="phani"    # this we need to set it cli
echo "My Name is :: $name"
if we exit and run script again it wont display 

If we want to display even the process kill we need to source it in user homw directory .bashrc file 
we need place the variables


How to use linux commands within shell and take output
variable_name=$(command)


special variables:
All variables to print , we can pass n number of values
$@
$*

$0 - current executed script name
$? - exit status     -> 0 for success   --> 1 to 127 failure
$$ - PID for current executed script
$PWD - current working directory
$USER - user name of running the script
$HOME - home directory of current user
$! - PID of last command in background


Datatypes:
---------
array
names=("siva","phani")
${names[0]} - 0th index value
${names[@]} - all values


Conditions:
-----------
if [ condition ]; then

fi
------------------------
if [ condition ]; then

else

fi 
-----------------------
if [ condition ]; then

elif [ condition ]; then 

else 

fi



Operators:
--------

-lt - less than
-gt - greater than
-eq - equals to 
-ne - not equals to 


exit :  By default shell script doesnot exit if there is any error in script
----
exit 0 - success exit
exit 1 - failure exit 


Functions:
----------
validate (){
    if [ $1 -ne 0 ]; then
    echo "Error :: installing $2 is Failed"
    exit 1
    else 
    echo "$2 Installing successfully"
    fi
}

function calling
validate $? "Mysql"


Colors:
red="\e[31m"
normal="\e[0m"


Logs:-
------
> <file-output>.log         ---> > for storing purpose
>>  ---> for appending to previous Logs

echo "Script started executed at: $(date)" | tee -a $LOG_FILE
dnf list installed $package &>>$LOG_FILE


Redirections:-
--------------
ls -l >/var/log/shell-script-practice/output.log
lsds -l 2>/var/log/shell-script-practice/output.log

1 for scccess storing , it is dy default
2 for failure storing


Set:
----
#!/bin/bash

set -e 
trap 'echo "There is an error in $LINENO, Command is: $BASH_COMMAND"' ERR
echo "Before error.."
ccaffjl;dnf # here shell understands there is an error and signal is ERR
echo "After error"






Delete old log files (older than 14 days)
-----------------------------------------

#!/bin/bash 

IS_ROOT_USER=$(id -u)

# check root user or not
if [ $IS_ROOT_USER -ne 0 ]; then
    echo "Root user privilege is needed to run this script"
    exit 1
fi

# storing logs in log file by creating a folder
LOGS_FOLDER="/var/log/shell-script-logs"
SCRIPT_NM=$( echo $0 | cut -d "." -f1 )
LOG_FILE_NM="$LOGS_FOLDER/$SCRIPT_NM.log"

mkdir -p $LOGS_FOLDER

SOURCE_DIR="/home/ec2-user/logs"

if [ ! -d $SOURCE_DIR]; then
    echo "Source directory not exist"
    exit 1
fi

FILES_TO_DELETE=$(find $SOURCE_DIR -name "*.log" -type f -mtime +14)

while IFS= read -r filepath
do 
echo "Deleting the file: $filepath"
rm -rf $filepath
echo "Deleted the file: $filepath"
done <<< $FILES_TO_DELETE





Archieve old log files
----------------------
#!/bin/bash

IS_ROOT_USER=$(id -u)

if [ $IS_ROOT_USER -ne 0 ]; then
    echo "Root user privilege is needed to run this script" | tee -a $LOG_FILE_NM
    exit 1
fi

# SOURCE_DIR="/home/ec2-user/source_directory"
# DESTINATION_DIR="/home/ec2-user/source_directory"
SOURCE_DIR=$1       #mandatory
DESTINATION_DIR=$2  #mandatory
DAYS=${3:-14}              #optional  here $3 means special variable , if user pass days it will consider , otherwise 14 days

if [ $# -lt 2 ]; then
    echo "Error :: sudo sh <file_name>.sh <source_directory_mandatory> <destination_directory_mandatory> <no_of_days_optional(default 14 days)>"
    exit 1
fi

LOGS_FOLDER="/var/log/shell-script-logs"
SCRIPT_NM=$(echo $0 | cut -d "." -f1)
mkdir -p "$LOGS_FOLDER"
LOG_FILE_NM="$LOGS_FOLDER/$SCRIPT_NM.log"


# find the files
# zip them
# move to destination
# then delete in the source directory

# check source and destination directory exist ot not

if [ ! -d $SOURCE_DIR ]; then
    echo "Source directory $SOURCE_DIR not exist" | tee -a $LOG_FILE_NM
    exit 1
fi 
if [ ! -d $DESTINATION_DIR ]; then
    echo "Destination directory $DESTINATION_DIR not exist" | tee -a $LOG_FILE_NM
    exit 1
fi 

dnf list installed zip
if [ $? -ne 0 ]; then
    dnf install zip -y
fi

FILES_TO_ZIP=$(find $SOURCE_DIR -name "*.log" -type f -mtime +$DAYS )

# checking file is empty or doesnot have content inside
if [ ! -z "${FILES_TO_ZIP}" ]; then
# zip them
    TIMESTAMP=$(date +%F-%H:%M)
    ZIP_FILE_NM="$DESTINATION_DIR/app-logs-$TIMESTAMP.zip"
    find $SOURCE_DIR -name "*.log" -type f -mtime +$DAYS | zip -@ -j "$ZIP_FILE_NM"

# check file is zipped or not
if [ -f $ZIP_FILE_NM ]; then
    echo "Successfully archieved $ZIP_FILE_NM" | tee -a $LOG_FILE_NM
    while IFS= read -r filepath
    do
    rm -rf "$filepath"
    done <<< "$FILES_TO_ZIP"
else
    echo "Issue while archieve"  | tee -a $LOG_FILE_NM
    exit 1
fi   
# move to destination directory

else
    echo "No files to archieve" | tee -a $LOG_FILE_NM
# No files to archieve
fi





